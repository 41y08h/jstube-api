
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: number
  name: string
  email: string
  picture: string | null
  provider: Provider
  providerAccountId: string
  createdAt: Date
}

/**
 * Model Video
 */

export type Video = {
  id: number
  title: string
  description: string
  src: string
  thumbnail: string
  duration: number
  userId: number
  views: number | null
  uploadedAt: Date
  updatedAt: Date
}

/**
 * Model Comment
 */

export type Comment = {
  id: number
  text: string
  baseCommentId: number | null
  replyToCommentId: number | null
  userId: number
  videoId: number
  commentedAt: Date
  editedAt: Date
}

/**
 * Model VideoRating
 */

export type VideoRating = {
  id: number
  status: RatingStatus
  userId: number
  videoId: number | null
}

/**
 * Model CommentRating
 */

export type CommentRating = {
  id: number
  status: RatingStatus
  userId: number
  commentId: number | null
}

/**
 * Model Subscriber
 */

export type Subscriber = {
  id: number
  channelId: number
  userId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Provider: {
  GOOGLE: 'GOOGLE'
};

export type Provider = (typeof Provider)[keyof typeof Provider]


export const RatingStatus: {
  LIKED: 'LIKED',
  DISLIKED: 'DISLIKED'
};

export type RatingStatus = (typeof RatingStatus)[keyof typeof RatingStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.videoRating`: Exposes CRUD operations for the **VideoRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoRatings
    * const videoRatings = await prisma.videoRating.findMany()
    * ```
    */
  get videoRating(): Prisma.VideoRatingDelegate<GlobalReject>;

  /**
   * `prisma.commentRating`: Exposes CRUD operations for the **CommentRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentRatings
    * const commentRatings = await prisma.commentRating.findMany()
    * ```
    */
  get commentRating(): Prisma.CommentRatingDelegate<GlobalReject>;

  /**
   * `prisma.subscriber`: Exposes CRUD operations for the **Subscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribers
    * const subscribers = await prisma.subscriber.findMany()
    * ```
    */
  get subscriber(): Prisma.SubscriberDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.22.1
   * Query Engine version: 60cc71d884972ab4e897f0277c4b84383dddaf6c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Video: 'Video',
    Comment: 'Comment',
    VideoRating: 'VideoRating',
    CommentRating: 'CommentRating',
    Subscriber: 'Subscriber'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    comments: number
    videos: number
    commentRatings: number
    videoRatings: number
    subscribers: number
    subscriptions: number
  }

  export type UserCountOutputTypeSelect = {
    comments?: boolean
    videos?: boolean
    commentRatings?: boolean
    videoRatings?: boolean
    subscribers?: boolean
    subscriptions?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type VideoCountOutputType
   */


  export type VideoCountOutputType = {
    comments: number
    ratings: number
  }

  export type VideoCountOutputTypeSelect = {
    comments?: boolean
    ratings?: boolean
  }

  export type VideoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VideoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VideoCountOutputType
    : S extends undefined
    ? never
    : S extends VideoCountOutputTypeArgs
    ?'include' extends U
    ? VideoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VideoCountOutputType ?VideoCountOutputType [P]
  : 
     never
  } 
    : VideoCountOutputType
  : VideoCountOutputType




  // Custom InputTypes

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
    **/
    select?: VideoCountOutputTypeSelect | null
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    replies: number
    directReplies: number
    Rating: number
  }

  export type CommentCountOutputTypeSelect = {
    replies?: boolean
    directReplies?: boolean
    Rating?: boolean
  }

  export type CommentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CommentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CommentCountOutputType
    : S extends undefined
    ? never
    : S extends CommentCountOutputTypeArgs
    ?'include' extends U
    ? CommentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommentCountOutputType ?CommentCountOutputType [P]
  : 
     never
  } 
    : CommentCountOutputType
  : CommentCountOutputType




  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
    **/
    select?: CommentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    picture: string | null
    provider: Provider | null
    providerAccountId: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    picture: string | null
    provider: Provider | null
    providerAccountId: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    picture: number
    provider: number
    providerAccountId: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    picture?: true
    provider?: true
    providerAccountId?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    picture?: true
    provider?: true
    providerAccountId?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    picture?: true
    provider?: true
    providerAccountId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCountAggregateInputType | true
    avg?: UserAvgAggregateInputType
    sum?: UserSumAggregateInputType
    min?: UserMinAggregateInputType
    max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    picture: string | null
    provider: Provider
    providerAccountId: string
    createdAt: Date
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<Array<
    PickArray<UserGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserGroupByOutputType))]: GetScalarType<T[P], UserGroupByOutputType[P]>
    }
  >>
    

  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    picture?: boolean
    provider?: boolean
    providerAccountId?: boolean
    comments?: boolean | CommentFindManyArgs
    videos?: boolean | VideoFindManyArgs
    createdAt?: boolean
    commentRatings?: boolean | CommentRatingFindManyArgs
    videoRatings?: boolean | VideoRatingFindManyArgs
    subscribers?: boolean | SubscriberFindManyArgs
    subscriptions?: boolean | SubscriberFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    comments?: boolean | CommentFindManyArgs
    videos?: boolean | VideoFindManyArgs
    commentRatings?: boolean | CommentRatingFindManyArgs
    videoRatings?: boolean | VideoRatingFindManyArgs
    subscribers?: boolean | SubscriberFindManyArgs
    subscriptions?: boolean | SubscriberFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'videos'
        ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends 'commentRatings'
        ? Array < CommentRatingGetPayload<S['include'][P]>>  :
        P extends 'videoRatings'
        ? Array < VideoRatingGetPayload<S['include'][P]>>  :
        P extends 'subscribers'
        ? Array < SubscriberGetPayload<S['include'][P]>>  :
        P extends 'subscriptions'
        ? Array < SubscriberGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'videos'
        ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends 'commentRatings'
        ? Array < CommentRatingGetPayload<S['select'][P]>>  :
        P extends 'videoRatings'
        ? Array < VideoRatingGetPayload<S['select'][P]>>  :
        P extends 'subscribers'
        ? Array < SubscriberGetPayload<S['select'][P]>>  :
        P extends 'subscriptions'
        ? Array < SubscriberGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    comments<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    videos<T extends VideoFindManyArgs = {}>(args?: Subset<T, VideoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Video>>, PrismaPromise<Array<VideoGetPayload<T>>>>;

    commentRatings<T extends CommentRatingFindManyArgs = {}>(args?: Subset<T, CommentRatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommentRating>>, PrismaPromise<Array<CommentRatingGetPayload<T>>>>;

    videoRatings<T extends VideoRatingFindManyArgs = {}>(args?: Subset<T, VideoRatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VideoRating>>, PrismaPromise<Array<VideoRatingGetPayload<T>>>>;

    subscribers<T extends SubscriberFindManyArgs = {}>(args?: Subset<T, SubscriberFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscriber>>, PrismaPromise<Array<SubscriberGetPayload<T>>>>;

    subscriptions<T extends SubscriberFindManyArgs = {}>(args?: Subset<T, SubscriberFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscriber>>, PrismaPromise<Array<SubscriberGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    count: VideoCountAggregateOutputType | null
    avg: VideoAvgAggregateOutputType | null
    sum: VideoSumAggregateOutputType | null
    min: VideoMinAggregateOutputType | null
    max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    userId: number | null
    views: number | null
  }

  export type VideoSumAggregateOutputType = {
    id: number | null
    duration: number | null
    userId: number | null
    views: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    src: string | null
    thumbnail: string | null
    duration: number | null
    userId: number | null
    views: number | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    src: string | null
    thumbnail: string | null
    duration: number | null
    userId: number | null
    views: number | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    description: number
    src: number
    thumbnail: number
    duration: number
    userId: number
    views: number
    uploadedAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    id?: true
    duration?: true
    userId?: true
    views?: true
  }

  export type VideoSumAggregateInputType = {
    id?: true
    duration?: true
    userId?: true
    views?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    src?: true
    thumbnail?: true
    duration?: true
    userId?: true
    views?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    src?: true
    thumbnail?: true
    duration?: true
    userId?: true
    views?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    src?: true
    thumbnail?: true
    duration?: true
    userId?: true
    views?: true
    uploadedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs = {
    /**
     * Filter which Video to aggregate.
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
    **/
    orderBy?: Enumerable<VideoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
    [P in keyof T & keyof AggregateVideo]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }


    
    
  export type VideoGroupByArgs = {
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByInput>
    by: Array<VideoScalarFieldEnum>
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: VideoCountAggregateInputType | true
    avg?: VideoAvgAggregateInputType
    sum?: VideoSumAggregateInputType
    min?: VideoMinAggregateInputType
    max?: VideoMaxAggregateInputType
  }


  export type VideoGroupByOutputType = {
    id: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    userId: number
    views: number | null
    uploadedAt: Date
    updatedAt: Date
    count: VideoCountAggregateOutputType | null
    avg: VideoAvgAggregateOutputType | null
    sum: VideoSumAggregateOutputType | null
    min: VideoMinAggregateOutputType | null
    max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Promise<Array<
    PickArray<VideoGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof VideoGroupByOutputType))]: GetScalarType<T[P], VideoGroupByOutputType[P]>
    }
  >>
    

  export type VideoSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    src?: boolean
    thumbnail?: boolean
    duration?: boolean
    userId?: boolean
    views?: boolean
    channel?: boolean | UserArgs
    comments?: boolean | CommentFindManyArgs
    uploadedAt?: boolean
    updatedAt?: boolean
    ratings?: boolean | VideoRatingFindManyArgs
    _count?: boolean | VideoCountOutputTypeArgs
  }

  export type VideoInclude = {
    channel?: boolean | UserArgs
    comments?: boolean | CommentFindManyArgs
    ratings?: boolean | VideoRatingFindManyArgs
    _count?: boolean | VideoCountOutputTypeArgs
  }

  export type VideoGetPayload<
    S extends boolean | null | undefined | VideoArgs,
    U = keyof S
      > = S extends true
        ? Video
    : S extends undefined
    ? never
    : S extends VideoArgs | VideoFindManyArgs
    ?'include' extends U
    ? Video  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'channel'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'ratings'
        ? Array < VideoRatingGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? VideoCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Video ?Video [P]
  : 
          P extends 'channel'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'ratings'
        ? Array < VideoRatingGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? VideoCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Video
  : Video


  type VideoCountArgs = Merge<
    Omit<VideoFindManyArgs, 'select' | 'include'> & {
      select?: VideoCountAggregateInputType | true
    }
  >

  export interface VideoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Video'> extends True ? CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>> : CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Video'> extends True ? CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>> : CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs>(
      args?: SelectSubset<T, VideoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Video>>, PrismaPromise<Array<VideoGetPayload<T>>>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: SelectSubset<T, VideoCreateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs>(
      args?: SelectSubset<T, VideoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: SelectSubset<T, VideoDeleteArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: SelectSubset<T, VideoUpdateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args?: SelectSubset<T, VideoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: SelectSubset<T, VideoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: SelectSubset<T, VideoUpsertArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    channel<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    comments<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    ratings<T extends VideoRatingFindManyArgs = {}>(args?: Subset<T, VideoRatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VideoRating>>, PrismaPromise<Array<VideoRatingGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * Throw an Error if a Video can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Video to fetch.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * Throw an Error if a Video can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Video to fetch.
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
    **/
    orderBy?: Enumerable<VideoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
    **/
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * Filter, which Videos to fetch.
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
    **/
    orderBy?: Enumerable<VideoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
    **/
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * The data needed to create a Video.
    **/
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs = {
    data: Enumerable<VideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * The data needed to update a Video.
    **/
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * The filter to search for the Video to update in case it exists.
    **/
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
    **/
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
    /**
     * Filter which Video to delete.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    where?: VideoWhereInput
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    count: CommentCountAggregateOutputType | null
    avg: CommentAvgAggregateOutputType | null
    sum: CommentSumAggregateOutputType | null
    min: CommentMinAggregateOutputType | null
    max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    baseCommentId: number | null
    replyToCommentId: number | null
    userId: number | null
    videoId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    baseCommentId: number | null
    replyToCommentId: number | null
    userId: number | null
    videoId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    text: string | null
    baseCommentId: number | null
    replyToCommentId: number | null
    userId: number | null
    videoId: number | null
    commentedAt: Date | null
    editedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    text: string | null
    baseCommentId: number | null
    replyToCommentId: number | null
    userId: number | null
    videoId: number | null
    commentedAt: Date | null
    editedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    baseCommentId: number
    replyToCommentId: number
    userId: number
    videoId: number
    commentedAt: number
    editedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    baseCommentId?: true
    replyToCommentId?: true
    userId?: true
    videoId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    baseCommentId?: true
    replyToCommentId?: true
    userId?: true
    videoId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
    baseCommentId?: true
    replyToCommentId?: true
    userId?: true
    videoId?: true
    commentedAt?: true
    editedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
    baseCommentId?: true
    replyToCommentId?: true
    userId?: true
    videoId?: true
    commentedAt?: true
    editedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    baseCommentId?: true
    replyToCommentId?: true
    userId?: true
    videoId?: true
    commentedAt?: true
    editedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }


    
    
  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByInput>
    by: Array<CommentScalarFieldEnum>
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommentCountAggregateInputType | true
    avg?: CommentAvgAggregateInputType
    sum?: CommentSumAggregateInputType
    min?: CommentMinAggregateInputType
    max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: number
    text: string
    baseCommentId: number | null
    replyToCommentId: number | null
    userId: number
    videoId: number
    commentedAt: Date
    editedAt: Date
    count: CommentCountAggregateOutputType | null
    avg: CommentAvgAggregateOutputType | null
    sum: CommentSumAggregateOutputType | null
    min: CommentMinAggregateOutputType | null
    max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Promise<Array<
    PickArray<CommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommentGroupByOutputType))]: GetScalarType<T[P], CommentGroupByOutputType[P]>
    }
  >>
    

  export type CommentSelect = {
    id?: boolean
    text?: boolean
    baseCommentId?: boolean
    baseComment?: boolean | CommentArgs
    replies?: boolean | CommentFindManyArgs
    replyToCommentId?: boolean
    replyToComment?: boolean | CommentArgs
    directReplies?: boolean | CommentFindManyArgs
    userId?: boolean
    author?: boolean | UserArgs
    videoId?: boolean
    commentedOnVideo?: boolean | VideoArgs
    commentedAt?: boolean
    editedAt?: boolean
    Rating?: boolean | CommentRatingFindManyArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentInclude = {
    baseComment?: boolean | CommentArgs
    replies?: boolean | CommentFindManyArgs
    replyToComment?: boolean | CommentArgs
    directReplies?: boolean | CommentFindManyArgs
    author?: boolean | UserArgs
    commentedOnVideo?: boolean | VideoArgs
    Rating?: boolean | CommentRatingFindManyArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentGetPayload<
    S extends boolean | null | undefined | CommentArgs,
    U = keyof S
      > = S extends true
        ? Comment
    : S extends undefined
    ? never
    : S extends CommentArgs | CommentFindManyArgs
    ?'include' extends U
    ? Comment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'baseComment'
        ? CommentGetPayload<S['include'][P]> | null :
        P extends 'replies'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'replyToComment'
        ? CommentGetPayload<S['include'][P]> | null :
        P extends 'directReplies'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'commentedOnVideo'
        ? VideoGetPayload<S['include'][P]> :
        P extends 'Rating'
        ? Array < CommentRatingGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CommentCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Comment ?Comment [P]
  : 
          P extends 'baseComment'
        ? CommentGetPayload<S['select'][P]> | null :
        P extends 'replies'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'replyToComment'
        ? CommentGetPayload<S['select'][P]> | null :
        P extends 'directReplies'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'commentedOnVideo'
        ? VideoGetPayload<S['select'][P]> :
        P extends 'Rating'
        ? Array < CommentRatingGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CommentCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Comment
  : Comment


  type CommentCountArgs = Merge<
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }
  >

  export interface CommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    baseComment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>;

    replies<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    replyToComment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>;

    directReplies<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    commentedOnVideo<T extends VideoArgs = {}>(args?: Subset<T, VideoArgs>): CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>;

    Rating<T extends CommentRatingFindManyArgs = {}>(args?: Subset<T, CommentRatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommentRating>>, PrismaPromise<Array<CommentRatingGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Throw an Error if a Comment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Throw an Error if a Comment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
    **/
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
    **/
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
    **/
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
    **/
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
    **/
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
  }



  /**
   * Model VideoRating
   */


  export type AggregateVideoRating = {
    count: VideoRatingCountAggregateOutputType | null
    avg: VideoRatingAvgAggregateOutputType | null
    sum: VideoRatingSumAggregateOutputType | null
    min: VideoRatingMinAggregateOutputType | null
    max: VideoRatingMaxAggregateOutputType | null
  }

  export type VideoRatingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type VideoRatingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type VideoRatingMinAggregateOutputType = {
    id: number | null
    status: RatingStatus | null
    userId: number | null
    videoId: number | null
  }

  export type VideoRatingMaxAggregateOutputType = {
    id: number | null
    status: RatingStatus | null
    userId: number | null
    videoId: number | null
  }

  export type VideoRatingCountAggregateOutputType = {
    id: number
    status: number
    userId: number
    videoId: number
    _all: number
  }


  export type VideoRatingAvgAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type VideoRatingSumAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type VideoRatingMinAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    videoId?: true
  }

  export type VideoRatingMaxAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    videoId?: true
  }

  export type VideoRatingCountAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    videoId?: true
    _all?: true
  }

  export type VideoRatingAggregateArgs = {
    /**
     * Filter which VideoRating to aggregate.
    **/
    where?: VideoRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRatings to fetch.
    **/
    orderBy?: Enumerable<VideoRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: VideoRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRatings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoRatings
    **/
    count?: true | VideoRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: VideoRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: VideoRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: VideoRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: VideoRatingMaxAggregateInputType
  }

  export type GetVideoRatingAggregateType<T extends VideoRatingAggregateArgs> = {
    [P in keyof T & keyof AggregateVideoRating]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoRating[P]>
      : GetScalarType<T[P], AggregateVideoRating[P]>
  }


    
    
  export type VideoRatingGroupByArgs = {
    where?: VideoRatingWhereInput
    orderBy?: Enumerable<VideoRatingOrderByInput>
    by: Array<VideoRatingScalarFieldEnum>
    having?: VideoRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: VideoRatingCountAggregateInputType | true
    avg?: VideoRatingAvgAggregateInputType
    sum?: VideoRatingSumAggregateInputType
    min?: VideoRatingMinAggregateInputType
    max?: VideoRatingMaxAggregateInputType
  }


  export type VideoRatingGroupByOutputType = {
    id: number
    status: RatingStatus
    userId: number
    videoId: number | null
    count: VideoRatingCountAggregateOutputType | null
    avg: VideoRatingAvgAggregateOutputType | null
    sum: VideoRatingSumAggregateOutputType | null
    min: VideoRatingMinAggregateOutputType | null
    max: VideoRatingMaxAggregateOutputType | null
  }

  type GetVideoRatingGroupByPayload<T extends VideoRatingGroupByArgs> = Promise<Array<
    PickArray<VideoRatingGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof VideoRatingGroupByOutputType))]: GetScalarType<T[P], VideoRatingGroupByOutputType[P]>
    }
  >>
    

  export type VideoRatingSelect = {
    id?: boolean
    status?: boolean
    userId?: boolean
    ratedBy?: boolean | UserArgs
    videoId?: boolean
    video?: boolean | VideoArgs
  }

  export type VideoRatingInclude = {
    ratedBy?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type VideoRatingGetPayload<
    S extends boolean | null | undefined | VideoRatingArgs,
    U = keyof S
      > = S extends true
        ? VideoRating
    : S extends undefined
    ? never
    : S extends VideoRatingArgs | VideoRatingFindManyArgs
    ?'include' extends U
    ? VideoRating  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ratedBy'
        ? UserGetPayload<S['include'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VideoRating ?VideoRating [P]
  : 
          P extends 'ratedBy'
        ? UserGetPayload<S['select'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['select'][P]> | null : never
  } 
    : VideoRating
  : VideoRating


  type VideoRatingCountArgs = Merge<
    Omit<VideoRatingFindManyArgs, 'select' | 'include'> & {
      select?: VideoRatingCountAggregateInputType | true
    }
  >

  export interface VideoRatingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VideoRating that matches the filter.
     * @param {VideoRatingFindUniqueArgs} args - Arguments to find a VideoRating
     * @example
     * // Get one VideoRating
     * const videoRating = await prisma.videoRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoRatingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoRatingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VideoRating'> extends True ? CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>> : CheckSelect<T, Prisma__VideoRatingClient<VideoRating | null >, Prisma__VideoRatingClient<VideoRatingGetPayload<T> | null >>

    /**
     * Find the first VideoRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingFindFirstArgs} args - Arguments to find a VideoRating
     * @example
     * // Get one VideoRating
     * const videoRating = await prisma.videoRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoRatingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoRatingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VideoRating'> extends True ? CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>> : CheckSelect<T, Prisma__VideoRatingClient<VideoRating | null >, Prisma__VideoRatingClient<VideoRatingGetPayload<T> | null >>

    /**
     * Find zero or more VideoRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoRatings
     * const videoRatings = await prisma.videoRating.findMany()
     * 
     * // Get first 10 VideoRatings
     * const videoRatings = await prisma.videoRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoRatingWithIdOnly = await prisma.videoRating.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoRatingFindManyArgs>(
      args?: SelectSubset<T, VideoRatingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VideoRating>>, PrismaPromise<Array<VideoRatingGetPayload<T>>>>

    /**
     * Create a VideoRating.
     * @param {VideoRatingCreateArgs} args - Arguments to create a VideoRating.
     * @example
     * // Create one VideoRating
     * const VideoRating = await prisma.videoRating.create({
     *   data: {
     *     // ... data to create a VideoRating
     *   }
     * })
     * 
    **/
    create<T extends VideoRatingCreateArgs>(
      args: SelectSubset<T, VideoRatingCreateArgs>
    ): CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>>

    /**
     * Create many VideoRatings.
     *     @param {VideoRatingCreateManyArgs} args - Arguments to create many VideoRatings.
     *     @example
     *     // Create many VideoRatings
     *     const videoRating = await prisma.videoRating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoRatingCreateManyArgs>(
      args?: SelectSubset<T, VideoRatingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VideoRating.
     * @param {VideoRatingDeleteArgs} args - Arguments to delete one VideoRating.
     * @example
     * // Delete one VideoRating
     * const VideoRating = await prisma.videoRating.delete({
     *   where: {
     *     // ... filter to delete one VideoRating
     *   }
     * })
     * 
    **/
    delete<T extends VideoRatingDeleteArgs>(
      args: SelectSubset<T, VideoRatingDeleteArgs>
    ): CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>>

    /**
     * Update one VideoRating.
     * @param {VideoRatingUpdateArgs} args - Arguments to update one VideoRating.
     * @example
     * // Update one VideoRating
     * const videoRating = await prisma.videoRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoRatingUpdateArgs>(
      args: SelectSubset<T, VideoRatingUpdateArgs>
    ): CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>>

    /**
     * Delete zero or more VideoRatings.
     * @param {VideoRatingDeleteManyArgs} args - Arguments to filter VideoRatings to delete.
     * @example
     * // Delete a few VideoRatings
     * const { count } = await prisma.videoRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoRatingDeleteManyArgs>(
      args?: SelectSubset<T, VideoRatingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoRatings
     * const videoRating = await prisma.videoRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoRatingUpdateManyArgs>(
      args: SelectSubset<T, VideoRatingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoRating.
     * @param {VideoRatingUpsertArgs} args - Arguments to update or create a VideoRating.
     * @example
     * // Update or create a VideoRating
     * const videoRating = await prisma.videoRating.upsert({
     *   create: {
     *     // ... data to create a VideoRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoRating we want to update
     *   }
     * })
    **/
    upsert<T extends VideoRatingUpsertArgs>(
      args: SelectSubset<T, VideoRatingUpsertArgs>
    ): CheckSelect<T, Prisma__VideoRatingClient<VideoRating>, Prisma__VideoRatingClient<VideoRatingGetPayload<T>>>

    /**
     * Count the number of VideoRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingCountArgs} args - Arguments to filter VideoRatings to count.
     * @example
     * // Count the number of VideoRatings
     * const count = await prisma.videoRating.count({
     *   where: {
     *     // ... the filter for the VideoRatings we want to count
     *   }
     * })
    **/
    count<T extends VideoRatingCountArgs>(
      args?: Subset<T, VideoRatingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoRatingAggregateArgs>(args: Subset<T, VideoRatingAggregateArgs>): PrismaPromise<GetVideoRatingAggregateType<T>>

    /**
     * Group by VideoRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoRatingGroupByArgs['orderBy'] }
        : { orderBy?: VideoRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoRatingGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoRatingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ratedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    video<T extends VideoArgs = {}>(args?: Subset<T, VideoArgs>): CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VideoRating findUnique
   */
  export type VideoRatingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * Throw an Error if a VideoRating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VideoRating to fetch.
    **/
    where: VideoRatingWhereUniqueInput
  }


  /**
   * VideoRating findFirst
   */
  export type VideoRatingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * Throw an Error if a VideoRating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VideoRating to fetch.
    **/
    where?: VideoRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRatings to fetch.
    **/
    orderBy?: Enumerable<VideoRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRatings.
    **/
    cursor?: VideoRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRatings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRatings.
    **/
    distinct?: Enumerable<VideoRatingScalarFieldEnum>
  }


  /**
   * VideoRating findMany
   */
  export type VideoRatingFindManyArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * Filter, which VideoRatings to fetch.
    **/
    where?: VideoRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRatings to fetch.
    **/
    orderBy?: Enumerable<VideoRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoRatings.
    **/
    cursor?: VideoRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRatings.
    **/
    skip?: number
    distinct?: Enumerable<VideoRatingScalarFieldEnum>
  }


  /**
   * VideoRating create
   */
  export type VideoRatingCreateArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * The data needed to create a VideoRating.
    **/
    data: XOR<VideoRatingCreateInput, VideoRatingUncheckedCreateInput>
  }


  /**
   * VideoRating createMany
   */
  export type VideoRatingCreateManyArgs = {
    data: Enumerable<VideoRatingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VideoRating update
   */
  export type VideoRatingUpdateArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * The data needed to update a VideoRating.
    **/
    data: XOR<VideoRatingUpdateInput, VideoRatingUncheckedUpdateInput>
    /**
     * Choose, which VideoRating to update.
    **/
    where: VideoRatingWhereUniqueInput
  }


  /**
   * VideoRating updateMany
   */
  export type VideoRatingUpdateManyArgs = {
    data: XOR<VideoRatingUpdateManyMutationInput, VideoRatingUncheckedUpdateManyInput>
    where?: VideoRatingWhereInput
  }


  /**
   * VideoRating upsert
   */
  export type VideoRatingUpsertArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * The filter to search for the VideoRating to update in case it exists.
    **/
    where: VideoRatingWhereUniqueInput
    /**
     * In case the VideoRating found by the `where` argument doesn't exist, create a new VideoRating with this data.
    **/
    create: XOR<VideoRatingCreateInput, VideoRatingUncheckedCreateInput>
    /**
     * In case the VideoRating was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<VideoRatingUpdateInput, VideoRatingUncheckedUpdateInput>
  }


  /**
   * VideoRating delete
   */
  export type VideoRatingDeleteArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
    /**
     * Filter which VideoRating to delete.
    **/
    where: VideoRatingWhereUniqueInput
  }


  /**
   * VideoRating deleteMany
   */
  export type VideoRatingDeleteManyArgs = {
    where?: VideoRatingWhereInput
  }


  /**
   * VideoRating without action
   */
  export type VideoRatingArgs = {
    /**
     * Select specific fields to fetch from the VideoRating
    **/
    select?: VideoRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VideoRatingInclude | null
  }



  /**
   * Model CommentRating
   */


  export type AggregateCommentRating = {
    count: CommentRatingCountAggregateOutputType | null
    avg: CommentRatingAvgAggregateOutputType | null
    sum: CommentRatingSumAggregateOutputType | null
    min: CommentRatingMinAggregateOutputType | null
    max: CommentRatingMaxAggregateOutputType | null
  }

  export type CommentRatingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
  }

  export type CommentRatingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    commentId: number | null
  }

  export type CommentRatingMinAggregateOutputType = {
    id: number | null
    status: RatingStatus | null
    userId: number | null
    commentId: number | null
  }

  export type CommentRatingMaxAggregateOutputType = {
    id: number | null
    status: RatingStatus | null
    userId: number | null
    commentId: number | null
  }

  export type CommentRatingCountAggregateOutputType = {
    id: number
    status: number
    userId: number
    commentId: number
    _all: number
  }


  export type CommentRatingAvgAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
  }

  export type CommentRatingSumAggregateInputType = {
    id?: true
    userId?: true
    commentId?: true
  }

  export type CommentRatingMinAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    commentId?: true
  }

  export type CommentRatingMaxAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    commentId?: true
  }

  export type CommentRatingCountAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    commentId?: true
    _all?: true
  }

  export type CommentRatingAggregateArgs = {
    /**
     * Filter which CommentRating to aggregate.
    **/
    where?: CommentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentRatings to fetch.
    **/
    orderBy?: Enumerable<CommentRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentRatings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentRatings
    **/
    count?: true | CommentRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommentRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommentRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommentRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommentRatingMaxAggregateInputType
  }

  export type GetCommentRatingAggregateType<T extends CommentRatingAggregateArgs> = {
    [P in keyof T & keyof AggregateCommentRating]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentRating[P]>
      : GetScalarType<T[P], AggregateCommentRating[P]>
  }


    
    
  export type CommentRatingGroupByArgs = {
    where?: CommentRatingWhereInput
    orderBy?: Enumerable<CommentRatingOrderByInput>
    by: Array<CommentRatingScalarFieldEnum>
    having?: CommentRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommentRatingCountAggregateInputType | true
    avg?: CommentRatingAvgAggregateInputType
    sum?: CommentRatingSumAggregateInputType
    min?: CommentRatingMinAggregateInputType
    max?: CommentRatingMaxAggregateInputType
  }


  export type CommentRatingGroupByOutputType = {
    id: number
    status: RatingStatus
    userId: number
    commentId: number | null
    count: CommentRatingCountAggregateOutputType | null
    avg: CommentRatingAvgAggregateOutputType | null
    sum: CommentRatingSumAggregateOutputType | null
    min: CommentRatingMinAggregateOutputType | null
    max: CommentRatingMaxAggregateOutputType | null
  }

  type GetCommentRatingGroupByPayload<T extends CommentRatingGroupByArgs> = Promise<Array<
    PickArray<CommentRatingGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommentRatingGroupByOutputType))]: GetScalarType<T[P], CommentRatingGroupByOutputType[P]>
    }
  >>
    

  export type CommentRatingSelect = {
    id?: boolean
    status?: boolean
    userId?: boolean
    ratedBy?: boolean | UserArgs
    commentId?: boolean
    comment?: boolean | CommentArgs
  }

  export type CommentRatingInclude = {
    ratedBy?: boolean | UserArgs
    comment?: boolean | CommentArgs
  }

  export type CommentRatingGetPayload<
    S extends boolean | null | undefined | CommentRatingArgs,
    U = keyof S
      > = S extends true
        ? CommentRating
    : S extends undefined
    ? never
    : S extends CommentRatingArgs | CommentRatingFindManyArgs
    ?'include' extends U
    ? CommentRating  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ratedBy'
        ? UserGetPayload<S['include'][P]> :
        P extends 'comment'
        ? CommentGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommentRating ?CommentRating [P]
  : 
          P extends 'ratedBy'
        ? UserGetPayload<S['select'][P]> :
        P extends 'comment'
        ? CommentGetPayload<S['select'][P]> | null : never
  } 
    : CommentRating
  : CommentRating


  type CommentRatingCountArgs = Merge<
    Omit<CommentRatingFindManyArgs, 'select' | 'include'> & {
      select?: CommentRatingCountAggregateInputType | true
    }
  >

  export interface CommentRatingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommentRating that matches the filter.
     * @param {CommentRatingFindUniqueArgs} args - Arguments to find a CommentRating
     * @example
     * // Get one CommentRating
     * const commentRating = await prisma.commentRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentRatingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentRatingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommentRating'> extends True ? CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>> : CheckSelect<T, Prisma__CommentRatingClient<CommentRating | null >, Prisma__CommentRatingClient<CommentRatingGetPayload<T> | null >>

    /**
     * Find the first CommentRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingFindFirstArgs} args - Arguments to find a CommentRating
     * @example
     * // Get one CommentRating
     * const commentRating = await prisma.commentRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentRatingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentRatingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommentRating'> extends True ? CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>> : CheckSelect<T, Prisma__CommentRatingClient<CommentRating | null >, Prisma__CommentRatingClient<CommentRatingGetPayload<T> | null >>

    /**
     * Find zero or more CommentRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentRatings
     * const commentRatings = await prisma.commentRating.findMany()
     * 
     * // Get first 10 CommentRatings
     * const commentRatings = await prisma.commentRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentRatingWithIdOnly = await prisma.commentRating.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentRatingFindManyArgs>(
      args?: SelectSubset<T, CommentRatingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommentRating>>, PrismaPromise<Array<CommentRatingGetPayload<T>>>>

    /**
     * Create a CommentRating.
     * @param {CommentRatingCreateArgs} args - Arguments to create a CommentRating.
     * @example
     * // Create one CommentRating
     * const CommentRating = await prisma.commentRating.create({
     *   data: {
     *     // ... data to create a CommentRating
     *   }
     * })
     * 
    **/
    create<T extends CommentRatingCreateArgs>(
      args: SelectSubset<T, CommentRatingCreateArgs>
    ): CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>>

    /**
     * Create many CommentRatings.
     *     @param {CommentRatingCreateManyArgs} args - Arguments to create many CommentRatings.
     *     @example
     *     // Create many CommentRatings
     *     const commentRating = await prisma.commentRating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentRatingCreateManyArgs>(
      args?: SelectSubset<T, CommentRatingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommentRating.
     * @param {CommentRatingDeleteArgs} args - Arguments to delete one CommentRating.
     * @example
     * // Delete one CommentRating
     * const CommentRating = await prisma.commentRating.delete({
     *   where: {
     *     // ... filter to delete one CommentRating
     *   }
     * })
     * 
    **/
    delete<T extends CommentRatingDeleteArgs>(
      args: SelectSubset<T, CommentRatingDeleteArgs>
    ): CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>>

    /**
     * Update one CommentRating.
     * @param {CommentRatingUpdateArgs} args - Arguments to update one CommentRating.
     * @example
     * // Update one CommentRating
     * const commentRating = await prisma.commentRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentRatingUpdateArgs>(
      args: SelectSubset<T, CommentRatingUpdateArgs>
    ): CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>>

    /**
     * Delete zero or more CommentRatings.
     * @param {CommentRatingDeleteManyArgs} args - Arguments to filter CommentRatings to delete.
     * @example
     * // Delete a few CommentRatings
     * const { count } = await prisma.commentRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentRatingDeleteManyArgs>(
      args?: SelectSubset<T, CommentRatingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentRatings
     * const commentRating = await prisma.commentRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentRatingUpdateManyArgs>(
      args: SelectSubset<T, CommentRatingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentRating.
     * @param {CommentRatingUpsertArgs} args - Arguments to update or create a CommentRating.
     * @example
     * // Update or create a CommentRating
     * const commentRating = await prisma.commentRating.upsert({
     *   create: {
     *     // ... data to create a CommentRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentRating we want to update
     *   }
     * })
    **/
    upsert<T extends CommentRatingUpsertArgs>(
      args: SelectSubset<T, CommentRatingUpsertArgs>
    ): CheckSelect<T, Prisma__CommentRatingClient<CommentRating>, Prisma__CommentRatingClient<CommentRatingGetPayload<T>>>

    /**
     * Count the number of CommentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingCountArgs} args - Arguments to filter CommentRatings to count.
     * @example
     * // Count the number of CommentRatings
     * const count = await prisma.commentRating.count({
     *   where: {
     *     // ... the filter for the CommentRatings we want to count
     *   }
     * })
    **/
    count<T extends CommentRatingCountArgs>(
      args?: Subset<T, CommentRatingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentRatingAggregateArgs>(args: Subset<T, CommentRatingAggregateArgs>): PrismaPromise<GetCommentRatingAggregateType<T>>

    /**
     * Group by CommentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentRatingGroupByArgs['orderBy'] }
        : { orderBy?: CommentRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentRatingGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentRatingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ratedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    comment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommentRating findUnique
   */
  export type CommentRatingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * Throw an Error if a CommentRating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommentRating to fetch.
    **/
    where: CommentRatingWhereUniqueInput
  }


  /**
   * CommentRating findFirst
   */
  export type CommentRatingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * Throw an Error if a CommentRating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommentRating to fetch.
    **/
    where?: CommentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentRatings to fetch.
    **/
    orderBy?: Enumerable<CommentRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentRatings.
    **/
    cursor?: CommentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentRatings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentRatings.
    **/
    distinct?: Enumerable<CommentRatingScalarFieldEnum>
  }


  /**
   * CommentRating findMany
   */
  export type CommentRatingFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * Filter, which CommentRatings to fetch.
    **/
    where?: CommentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentRatings to fetch.
    **/
    orderBy?: Enumerable<CommentRatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentRatings.
    **/
    cursor?: CommentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentRatings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentRatings.
    **/
    skip?: number
    distinct?: Enumerable<CommentRatingScalarFieldEnum>
  }


  /**
   * CommentRating create
   */
  export type CommentRatingCreateArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * The data needed to create a CommentRating.
    **/
    data: XOR<CommentRatingCreateInput, CommentRatingUncheckedCreateInput>
  }


  /**
   * CommentRating createMany
   */
  export type CommentRatingCreateManyArgs = {
    data: Enumerable<CommentRatingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommentRating update
   */
  export type CommentRatingUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * The data needed to update a CommentRating.
    **/
    data: XOR<CommentRatingUpdateInput, CommentRatingUncheckedUpdateInput>
    /**
     * Choose, which CommentRating to update.
    **/
    where: CommentRatingWhereUniqueInput
  }


  /**
   * CommentRating updateMany
   */
  export type CommentRatingUpdateManyArgs = {
    data: XOR<CommentRatingUpdateManyMutationInput, CommentRatingUncheckedUpdateManyInput>
    where?: CommentRatingWhereInput
  }


  /**
   * CommentRating upsert
   */
  export type CommentRatingUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * The filter to search for the CommentRating to update in case it exists.
    **/
    where: CommentRatingWhereUniqueInput
    /**
     * In case the CommentRating found by the `where` argument doesn't exist, create a new CommentRating with this data.
    **/
    create: XOR<CommentRatingCreateInput, CommentRatingUncheckedCreateInput>
    /**
     * In case the CommentRating was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommentRatingUpdateInput, CommentRatingUncheckedUpdateInput>
  }


  /**
   * CommentRating delete
   */
  export type CommentRatingDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
    /**
     * Filter which CommentRating to delete.
    **/
    where: CommentRatingWhereUniqueInput
  }


  /**
   * CommentRating deleteMany
   */
  export type CommentRatingDeleteManyArgs = {
    where?: CommentRatingWhereInput
  }


  /**
   * CommentRating without action
   */
  export type CommentRatingArgs = {
    /**
     * Select specific fields to fetch from the CommentRating
    **/
    select?: CommentRatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentRatingInclude | null
  }



  /**
   * Model Subscriber
   */


  export type AggregateSubscriber = {
    count: SubscriberCountAggregateOutputType | null
    avg: SubscriberAvgAggregateOutputType | null
    sum: SubscriberSumAggregateOutputType | null
    min: SubscriberMinAggregateOutputType | null
    max: SubscriberMaxAggregateOutputType | null
  }

  export type SubscriberAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
    userId: number | null
  }

  export type SubscriberSumAggregateOutputType = {
    id: number | null
    channelId: number | null
    userId: number | null
  }

  export type SubscriberMinAggregateOutputType = {
    id: number | null
    channelId: number | null
    userId: number | null
  }

  export type SubscriberMaxAggregateOutputType = {
    id: number | null
    channelId: number | null
    userId: number | null
  }

  export type SubscriberCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    _all: number
  }


  export type SubscriberAvgAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
  }

  export type SubscriberSumAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
  }

  export type SubscriberMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
  }

  export type SubscriberMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
  }

  export type SubscriberCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    _all?: true
  }

  export type SubscriberAggregateArgs = {
    /**
     * Filter which Subscriber to aggregate.
    **/
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
    **/
    orderBy?: Enumerable<SubscriberOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribers
    **/
    count?: true | SubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SubscriberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SubscriberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SubscriberMaxAggregateInputType
  }

  export type GetSubscriberAggregateType<T extends SubscriberAggregateArgs> = {
    [P in keyof T & keyof AggregateSubscriber]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriber[P]>
      : GetScalarType<T[P], AggregateSubscriber[P]>
  }


    
    
  export type SubscriberGroupByArgs = {
    where?: SubscriberWhereInput
    orderBy?: Enumerable<SubscriberOrderByInput>
    by: Array<SubscriberScalarFieldEnum>
    having?: SubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SubscriberCountAggregateInputType | true
    avg?: SubscriberAvgAggregateInputType
    sum?: SubscriberSumAggregateInputType
    min?: SubscriberMinAggregateInputType
    max?: SubscriberMaxAggregateInputType
  }


  export type SubscriberGroupByOutputType = {
    id: number
    channelId: number
    userId: number
    count: SubscriberCountAggregateOutputType | null
    avg: SubscriberAvgAggregateOutputType | null
    sum: SubscriberSumAggregateOutputType | null
    min: SubscriberMinAggregateOutputType | null
    max: SubscriberMaxAggregateOutputType | null
  }

  type GetSubscriberGroupByPayload<T extends SubscriberGroupByArgs> = Promise<Array<
    PickArray<SubscriberGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SubscriberGroupByOutputType))]: GetScalarType<T[P], SubscriberGroupByOutputType[P]>
    }
  >>
    

  export type SubscriberSelect = {
    id?: boolean
    channelId?: boolean
    channel?: boolean | UserArgs
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type SubscriberInclude = {
    channel?: boolean | UserArgs
    user?: boolean | UserArgs
  }

  export type SubscriberGetPayload<
    S extends boolean | null | undefined | SubscriberArgs,
    U = keyof S
      > = S extends true
        ? Subscriber
    : S extends undefined
    ? never
    : S extends SubscriberArgs | SubscriberFindManyArgs
    ?'include' extends U
    ? Subscriber  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'channel'
        ? UserGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Subscriber ?Subscriber [P]
  : 
          P extends 'channel'
        ? UserGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Subscriber
  : Subscriber


  type SubscriberCountArgs = Merge<
    Omit<SubscriberFindManyArgs, 'select' | 'include'> & {
      select?: SubscriberCountAggregateInputType | true
    }
  >

  export interface SubscriberDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subscriber that matches the filter.
     * @param {SubscriberFindUniqueArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscriber'> extends True ? CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>> : CheckSelect<T, Prisma__SubscriberClient<Subscriber | null >, Prisma__SubscriberClient<SubscriberGetPayload<T> | null >>

    /**
     * Find the first Subscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscriber'> extends True ? CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>> : CheckSelect<T, Prisma__SubscriberClient<Subscriber | null >, Prisma__SubscriberClient<SubscriberGetPayload<T> | null >>

    /**
     * Find zero or more Subscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribers
     * const subscribers = await prisma.subscriber.findMany()
     * 
     * // Get first 10 Subscribers
     * const subscribers = await prisma.subscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriberFindManyArgs>(
      args?: SelectSubset<T, SubscriberFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subscriber>>, PrismaPromise<Array<SubscriberGetPayload<T>>>>

    /**
     * Create a Subscriber.
     * @param {SubscriberCreateArgs} args - Arguments to create a Subscriber.
     * @example
     * // Create one Subscriber
     * const Subscriber = await prisma.subscriber.create({
     *   data: {
     *     // ... data to create a Subscriber
     *   }
     * })
     * 
    **/
    create<T extends SubscriberCreateArgs>(
      args: SelectSubset<T, SubscriberCreateArgs>
    ): CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>>

    /**
     * Create many Subscribers.
     *     @param {SubscriberCreateManyArgs} args - Arguments to create many Subscribers.
     *     @example
     *     // Create many Subscribers
     *     const subscriber = await prisma.subscriber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriberCreateManyArgs>(
      args?: SelectSubset<T, SubscriberCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriber.
     * @param {SubscriberDeleteArgs} args - Arguments to delete one Subscriber.
     * @example
     * // Delete one Subscriber
     * const Subscriber = await prisma.subscriber.delete({
     *   where: {
     *     // ... filter to delete one Subscriber
     *   }
     * })
     * 
    **/
    delete<T extends SubscriberDeleteArgs>(
      args: SelectSubset<T, SubscriberDeleteArgs>
    ): CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>>

    /**
     * Update one Subscriber.
     * @param {SubscriberUpdateArgs} args - Arguments to update one Subscriber.
     * @example
     * // Update one Subscriber
     * const subscriber = await prisma.subscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriberUpdateArgs>(
      args: SelectSubset<T, SubscriberUpdateArgs>
    ): CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>>

    /**
     * Delete zero or more Subscribers.
     * @param {SubscriberDeleteManyArgs} args - Arguments to filter Subscribers to delete.
     * @example
     * // Delete a few Subscribers
     * const { count } = await prisma.subscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriberDeleteManyArgs>(
      args?: SelectSubset<T, SubscriberDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriberUpdateManyArgs>(
      args: SelectSubset<T, SubscriberUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriber.
     * @param {SubscriberUpsertArgs} args - Arguments to update or create a Subscriber.
     * @example
     * // Update or create a Subscriber
     * const subscriber = await prisma.subscriber.upsert({
     *   create: {
     *     // ... data to create a Subscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriber we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriberUpsertArgs>(
      args: SelectSubset<T, SubscriberUpsertArgs>
    ): CheckSelect<T, Prisma__SubscriberClient<Subscriber>, Prisma__SubscriberClient<SubscriberGetPayload<T>>>

    /**
     * Count the number of Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberCountArgs} args - Arguments to filter Subscribers to count.
     * @example
     * // Count the number of Subscribers
     * const count = await prisma.subscriber.count({
     *   where: {
     *     // ... the filter for the Subscribers we want to count
     *   }
     * })
    **/
    count<T extends SubscriberCountArgs>(
      args?: Subset<T, SubscriberCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberAggregateArgs>(args: Subset<T, SubscriberAggregateArgs>): PrismaPromise<GetSubscriberAggregateType<T>>

    /**
     * Group by Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriberClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    channel<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Subscriber findUnique
   */
  export type SubscriberFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * Throw an Error if a Subscriber can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subscriber to fetch.
    **/
    where: SubscriberWhereUniqueInput
  }


  /**
   * Subscriber findFirst
   */
  export type SubscriberFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * Throw an Error if a Subscriber can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subscriber to fetch.
    **/
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
    **/
    orderBy?: Enumerable<SubscriberOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
    **/
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
    **/
    distinct?: Enumerable<SubscriberScalarFieldEnum>
  }


  /**
   * Subscriber findMany
   */
  export type SubscriberFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * Filter, which Subscribers to fetch.
    **/
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
    **/
    orderBy?: Enumerable<SubscriberOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribers.
    **/
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
    **/
    skip?: number
    distinct?: Enumerable<SubscriberScalarFieldEnum>
  }


  /**
   * Subscriber create
   */
  export type SubscriberCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * The data needed to create a Subscriber.
    **/
    data: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
  }


  /**
   * Subscriber createMany
   */
  export type SubscriberCreateManyArgs = {
    data: Enumerable<SubscriberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscriber update
   */
  export type SubscriberUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * The data needed to update a Subscriber.
    **/
    data: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
    /**
     * Choose, which Subscriber to update.
    **/
    where: SubscriberWhereUniqueInput
  }


  /**
   * Subscriber updateMany
   */
  export type SubscriberUpdateManyArgs = {
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    where?: SubscriberWhereInput
  }


  /**
   * Subscriber upsert
   */
  export type SubscriberUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * The filter to search for the Subscriber to update in case it exists.
    **/
    where: SubscriberWhereUniqueInput
    /**
     * In case the Subscriber found by the `where` argument doesn't exist, create a new Subscriber with this data.
    **/
    create: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
    /**
     * In case the Subscriber was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
  }


  /**
   * Subscriber delete
   */
  export type SubscriberDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
    /**
     * Filter which Subscriber to delete.
    **/
    where: SubscriberWhereUniqueInput
  }


  /**
   * Subscriber deleteMany
   */
  export type SubscriberDeleteManyArgs = {
    where?: SubscriberWhereInput
  }


  /**
   * Subscriber without action
   */
  export type SubscriberArgs = {
    /**
     * Select specific fields to fetch from the Subscriber
    **/
    select?: SubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubscriberInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    picture: 'picture',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    src: 'src',
    thumbnail: 'thumbnail',
    duration: 'duration',
    userId: 'userId',
    views: 'views',
    uploadedAt: 'uploadedAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    baseCommentId: 'baseCommentId',
    replyToCommentId: 'replyToCommentId',
    userId: 'userId',
    videoId: 'videoId',
    commentedAt: 'commentedAt',
    editedAt: 'editedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const VideoRatingScalarFieldEnum: {
    id: 'id',
    status: 'status',
    userId: 'userId',
    videoId: 'videoId'
  };

  export type VideoRatingScalarFieldEnum = (typeof VideoRatingScalarFieldEnum)[keyof typeof VideoRatingScalarFieldEnum]


  export const CommentRatingScalarFieldEnum: {
    id: 'id',
    status: 'status',
    userId: 'userId',
    commentId: 'commentId'
  };

  export type CommentRatingScalarFieldEnum = (typeof CommentRatingScalarFieldEnum)[keyof typeof CommentRatingScalarFieldEnum]


  export const SubscriberScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId'
  };

  export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    picture?: StringNullableFilter | string | null
    provider?: EnumProviderFilter | Provider
    providerAccountId?: StringFilter | string
    comments?: CommentListRelationFilter
    videos?: VideoListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    commentRatings?: CommentRatingListRelationFilter
    videoRatings?: VideoRatingListRelationFilter
    subscribers?: SubscriberListRelationFilter
    subscriptions?: SubscriberListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    picture?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    picture?: StringNullableWithAggregatesFilter | string | null
    provider?: EnumProviderWithAggregatesFilter | Provider
    providerAccountId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoWhereInput = {
    AND?: Enumerable<VideoWhereInput>
    OR?: Enumerable<VideoWhereInput>
    NOT?: Enumerable<VideoWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    src?: StringFilter | string
    thumbnail?: StringFilter | string
    duration?: IntFilter | number
    userId?: IntFilter | number
    views?: IntNullableFilter | number | null
    channel?: XOR<UserRelationFilter, UserWhereInput> | null
    comments?: CommentListRelationFilter
    uploadedAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ratings?: VideoRatingListRelationFilter
  }

  export type VideoOrderByInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    src?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoWhereUniqueInput = {
    id?: number
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    src?: StringWithAggregatesFilter | string
    thumbnail?: StringWithAggregatesFilter | string
    duration?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    views?: IntNullableWithAggregatesFilter | number | null
    uploadedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    baseCommentId?: IntNullableFilter | number | null
    baseComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    replyToCommentId?: IntNullableFilter | number | null
    replyToComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    directReplies?: CommentListRelationFilter
    userId?: IntFilter | number
    author?: XOR<UserRelationFilter, UserWhereInput>
    videoId?: IntFilter | number
    commentedOnVideo?: XOR<VideoRelationFilter, VideoWhereInput>
    commentedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    Rating?: CommentRatingListRelationFilter
  }

  export type CommentOrderByInput = {
    id?: SortOrder
    text?: SortOrder
    baseCommentId?: SortOrder
    replyToCommentId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    commentedAt?: SortOrder
    editedAt?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: number
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    baseCommentId?: IntNullableWithAggregatesFilter | number | null
    replyToCommentId?: IntNullableWithAggregatesFilter | number | null
    userId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    commentedAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoRatingWhereInput = {
    AND?: Enumerable<VideoRatingWhereInput>
    OR?: Enumerable<VideoRatingWhereInput>
    NOT?: Enumerable<VideoRatingWhereInput>
    id?: IntFilter | number
    status?: EnumRatingStatusFilter | RatingStatus
    userId?: IntFilter | number
    ratedBy?: XOR<UserRelationFilter, UserWhereInput>
    videoId?: IntNullableFilter | number | null
    video?: XOR<VideoRelationFilter, VideoWhereInput> | null
  }

  export type VideoRatingOrderByInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type VideoRatingWhereUniqueInput = {
    id?: number
    videoId_userId?: VideoRatingVideoIdUserIdCompoundUniqueInput
  }

  export type VideoRatingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoRatingScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoRatingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoRatingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: EnumRatingStatusWithAggregatesFilter | RatingStatus
    userId?: IntWithAggregatesFilter | number
    videoId?: IntNullableWithAggregatesFilter | number | null
  }

  export type CommentRatingWhereInput = {
    AND?: Enumerable<CommentRatingWhereInput>
    OR?: Enumerable<CommentRatingWhereInput>
    NOT?: Enumerable<CommentRatingWhereInput>
    id?: IntFilter | number
    status?: EnumRatingStatusFilter | RatingStatus
    userId?: IntFilter | number
    ratedBy?: XOR<UserRelationFilter, UserWhereInput>
    commentId?: IntNullableFilter | number | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput> | null
  }

  export type CommentRatingOrderByInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
  }

  export type CommentRatingWhereUniqueInput = {
    id?: number
    commentId_userId?: CommentRatingCommentIdUserIdCompoundUniqueInput
  }

  export type CommentRatingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentRatingScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentRatingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentRatingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: EnumRatingStatusWithAggregatesFilter | RatingStatus
    userId?: IntWithAggregatesFilter | number
    commentId?: IntNullableWithAggregatesFilter | number | null
  }

  export type SubscriberWhereInput = {
    AND?: Enumerable<SubscriberWhereInput>
    OR?: Enumerable<SubscriberWhereInput>
    NOT?: Enumerable<SubscriberWhereInput>
    id?: IntFilter | number
    channelId?: IntFilter | number
    channel?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriberOrderByInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
  }

  export type SubscriberWhereUniqueInput = {
    id?: number
    channelId_userId?: SubscriberChannelIdUserIdCompoundUniqueInput
  }

  export type SubscriberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriberScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriberScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    videos?: VideoCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    videos?: VideoUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    channel?: UserCreateNestedOneWithoutVideosInput
    comments?: CommentCreateNestedManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    userId: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: UserUpdateOneWithoutVideosInput
    comments?: CommentUpdateManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUpdateManyWithoutVideoInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUncheckedUpdateManyWithoutVideoInput
  }

  export type VideoCreateManyInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    userId: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentCreateManyInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRatingCreateInput = {
    status: RatingStatus
    ratedBy: UserCreateNestedOneWithoutVideoRatingsInput
    video?: VideoCreateNestedOneWithoutRatingsInput
  }

  export type VideoRatingUncheckedCreateInput = {
    id?: number
    status: RatingStatus
    userId: number
    videoId?: number | null
  }

  export type VideoRatingUpdateInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    ratedBy?: UserUpdateOneRequiredWithoutVideoRatingsInput
    video?: VideoUpdateOneWithoutRatingsInput
  }

  export type VideoRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoRatingCreateManyInput = {
    id?: number
    status: RatingStatus
    userId: number
    videoId?: number | null
  }

  export type VideoRatingUpdateManyMutationInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
  }

  export type VideoRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentRatingCreateInput = {
    status: RatingStatus
    ratedBy: UserCreateNestedOneWithoutCommentRatingsInput
    comment?: CommentCreateNestedOneWithoutRatingInput
  }

  export type CommentRatingUncheckedCreateInput = {
    id?: number
    status: RatingStatus
    userId: number
    commentId?: number | null
  }

  export type CommentRatingUpdateInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    ratedBy?: UserUpdateOneRequiredWithoutCommentRatingsInput
    comment?: CommentUpdateOneWithoutRatingInput
  }

  export type CommentRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentRatingCreateManyInput = {
    id?: number
    status: RatingStatus
    userId: number
    commentId?: number | null
  }

  export type CommentRatingUpdateManyMutationInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
  }

  export type CommentRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubscriberCreateInput = {
    channel: UserCreateNestedOneWithoutSubscriptionsInput
    user: UserCreateNestedOneWithoutSubscribersInput
  }

  export type SubscriberUncheckedCreateInput = {
    id?: number
    channelId: number
    userId: number
  }

  export type SubscriberUpdateInput = {
    channel?: UserUpdateOneRequiredWithoutSubscriptionsInput
    user?: UserUpdateOneRequiredWithoutSubscribersInput
  }

  export type SubscriberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriberCreateManyInput = {
    id?: number
    channelId: number
    userId: number
  }

  export type SubscriberUpdateManyMutationInput = {

  }

  export type SubscriberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumProviderFilter = {
    equals?: Provider
    in?: Enumerable<Provider>
    notIn?: Enumerable<Provider>
    not?: NestedEnumProviderFilter | Provider
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CommentRatingListRelationFilter = {
    every?: CommentRatingWhereInput
    some?: CommentRatingWhereInput
    none?: CommentRatingWhereInput
  }

  export type VideoRatingListRelationFilter = {
    every?: VideoRatingWhereInput
    some?: VideoRatingWhereInput
    none?: VideoRatingWhereInput
  }

  export type SubscriberListRelationFilter = {
    every?: SubscriberWhereInput
    some?: SubscriberWhereInput
    none?: SubscriberWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type EnumProviderWithAggregatesFilter = {
    equals?: Provider
    in?: Enumerable<Provider>
    notIn?: Enumerable<Provider>
    not?: NestedEnumProviderWithAggregatesFilter | Provider
    count?: NestedIntFilter
    min?: NestedEnumProviderFilter
    max?: NestedEnumProviderFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput | null
    isNot?: VideoWhereInput | null
  }

  export type EnumRatingStatusFilter = {
    equals?: RatingStatus
    in?: Enumerable<RatingStatus>
    notIn?: Enumerable<RatingStatus>
    not?: NestedEnumRatingStatusFilter | RatingStatus
  }

  export type VideoRatingVideoIdUserIdCompoundUniqueInput = {
    videoId: number
    userId: number
  }

  export type EnumRatingStatusWithAggregatesFilter = {
    equals?: RatingStatus
    in?: Enumerable<RatingStatus>
    notIn?: Enumerable<RatingStatus>
    not?: NestedEnumRatingStatusWithAggregatesFilter | RatingStatus
    count?: NestedIntFilter
    min?: NestedEnumRatingStatusFilter
    max?: NestedEnumRatingStatusFilter
  }

  export type CommentRatingCommentIdUserIdCompoundUniqueInput = {
    commentId: number
    userId: number
  }

  export type SubscriberChannelIdUserIdCompoundUniqueInput = {
    channelId: number
    userId: number
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutChannelInput>, Enumerable<VideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutChannelInput>
    createMany?: VideoCreateManyChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type CommentRatingCreateNestedManyWithoutRatedByInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutRatedByInput>, Enumerable<CommentRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutRatedByInput>
    createMany?: CommentRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
  }

  export type VideoRatingCreateNestedManyWithoutRatedByInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutRatedByInput>, Enumerable<VideoRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutRatedByInput>
    createMany?: VideoRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
  }

  export type SubscriberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutUserInput>, Enumerable<SubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutUserInput>
    createMany?: SubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
  }

  export type SubscriberCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutChannelInput>, Enumerable<SubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutChannelInput>
    createMany?: SubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutChannelInput>, Enumerable<VideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutChannelInput>
    createMany?: VideoCreateManyChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type CommentRatingUncheckedCreateNestedManyWithoutRatedByInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutRatedByInput>, Enumerable<CommentRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutRatedByInput>
    createMany?: CommentRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
  }

  export type VideoRatingUncheckedCreateNestedManyWithoutRatedByInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutRatedByInput>, Enumerable<VideoRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutRatedByInput>
    createMany?: VideoRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
  }

  export type SubscriberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutUserInput>, Enumerable<SubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutUserInput>
    createMany?: SubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
  }

  export type SubscriberUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutChannelInput>, Enumerable<SubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutChannelInput>
    createMany?: SubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumProviderFieldUpdateOperationsInput = {
    set?: Provider
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommentUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type VideoUpdateManyWithoutChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutChannelInput>, Enumerable<VideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: VideoCreateManyChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type CommentRatingUpdateManyWithoutRatedByInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutRatedByInput>, Enumerable<CommentRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutRatedByInput>
    upsert?: Enumerable<CommentRatingUpsertWithWhereUniqueWithoutRatedByInput>
    createMany?: CommentRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
    set?: Enumerable<CommentRatingWhereUniqueInput>
    disconnect?: Enumerable<CommentRatingWhereUniqueInput>
    delete?: Enumerable<CommentRatingWhereUniqueInput>
    update?: Enumerable<CommentRatingUpdateWithWhereUniqueWithoutRatedByInput>
    updateMany?: Enumerable<CommentRatingUpdateManyWithWhereWithoutRatedByInput>
    deleteMany?: Enumerable<CommentRatingScalarWhereInput>
  }

  export type VideoRatingUpdateManyWithoutRatedByInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutRatedByInput>, Enumerable<VideoRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutRatedByInput>
    upsert?: Enumerable<VideoRatingUpsertWithWhereUniqueWithoutRatedByInput>
    createMany?: VideoRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
    set?: Enumerable<VideoRatingWhereUniqueInput>
    disconnect?: Enumerable<VideoRatingWhereUniqueInput>
    delete?: Enumerable<VideoRatingWhereUniqueInput>
    update?: Enumerable<VideoRatingUpdateWithWhereUniqueWithoutRatedByInput>
    updateMany?: Enumerable<VideoRatingUpdateManyWithWhereWithoutRatedByInput>
    deleteMany?: Enumerable<VideoRatingScalarWhereInput>
  }

  export type SubscriberUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutUserInput>, Enumerable<SubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
    set?: Enumerable<SubscriberWhereUniqueInput>
    disconnect?: Enumerable<SubscriberWhereUniqueInput>
    delete?: Enumerable<SubscriberWhereUniqueInput>
    update?: Enumerable<SubscriberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriberScalarWhereInput>
  }

  export type SubscriberUpdateManyWithoutChannelInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutChannelInput>, Enumerable<SubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<SubscriberUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: SubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
    set?: Enumerable<SubscriberWhereUniqueInput>
    disconnect?: Enumerable<SubscriberWhereUniqueInput>
    delete?: Enumerable<SubscriberWhereUniqueInput>
    update?: Enumerable<SubscriberUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<SubscriberUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<SubscriberScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutChannelInput>, Enumerable<VideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: VideoCreateManyChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type CommentRatingUncheckedUpdateManyWithoutRatedByInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutRatedByInput>, Enumerable<CommentRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutRatedByInput>
    upsert?: Enumerable<CommentRatingUpsertWithWhereUniqueWithoutRatedByInput>
    createMany?: CommentRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
    set?: Enumerable<CommentRatingWhereUniqueInput>
    disconnect?: Enumerable<CommentRatingWhereUniqueInput>
    delete?: Enumerable<CommentRatingWhereUniqueInput>
    update?: Enumerable<CommentRatingUpdateWithWhereUniqueWithoutRatedByInput>
    updateMany?: Enumerable<CommentRatingUpdateManyWithWhereWithoutRatedByInput>
    deleteMany?: Enumerable<CommentRatingScalarWhereInput>
  }

  export type VideoRatingUncheckedUpdateManyWithoutRatedByInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutRatedByInput>, Enumerable<VideoRatingUncheckedCreateWithoutRatedByInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutRatedByInput>
    upsert?: Enumerable<VideoRatingUpsertWithWhereUniqueWithoutRatedByInput>
    createMany?: VideoRatingCreateManyRatedByInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
    set?: Enumerable<VideoRatingWhereUniqueInput>
    disconnect?: Enumerable<VideoRatingWhereUniqueInput>
    delete?: Enumerable<VideoRatingWhereUniqueInput>
    update?: Enumerable<VideoRatingUpdateWithWhereUniqueWithoutRatedByInput>
    updateMany?: Enumerable<VideoRatingUpdateManyWithWhereWithoutRatedByInput>
    deleteMany?: Enumerable<VideoRatingScalarWhereInput>
  }

  export type SubscriberUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutUserInput>, Enumerable<SubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
    set?: Enumerable<SubscriberWhereUniqueInput>
    disconnect?: Enumerable<SubscriberWhereUniqueInput>
    delete?: Enumerable<SubscriberWhereUniqueInput>
    update?: Enumerable<SubscriberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriberScalarWhereInput>
  }

  export type SubscriberUncheckedUpdateManyWithoutChannelInput = {
    create?: XOR<Enumerable<SubscriberCreateWithoutChannelInput>, Enumerable<SubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<SubscriberCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<SubscriberUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: SubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<SubscriberWhereUniqueInput>
    set?: Enumerable<SubscriberWhereUniqueInput>
    disconnect?: Enumerable<SubscriberWhereUniqueInput>
    delete?: Enumerable<SubscriberWhereUniqueInput>
    update?: Enumerable<SubscriberUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<SubscriberUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<SubscriberScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutVideosInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutCommentedOnVideoInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentedOnVideoInput>, Enumerable<CommentUncheckedCreateWithoutCommentedOnVideoInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentedOnVideoInput>
    createMany?: CommentCreateManyCommentedOnVideoInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type VideoRatingCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutVideoInput>, Enumerable<VideoRatingUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutVideoInput>
    createMany?: VideoRatingCreateManyVideoInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutCommentedOnVideoInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentedOnVideoInput>, Enumerable<CommentUncheckedCreateWithoutCommentedOnVideoInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentedOnVideoInput>
    createMany?: CommentCreateManyCommentedOnVideoInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type VideoRatingUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutVideoInput>, Enumerable<VideoRatingUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutVideoInput>
    createMany?: VideoRatingCreateManyVideoInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutVideosInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    upsert?: UserUpsertWithoutVideosInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
  }

  export type CommentUpdateManyWithoutCommentedOnVideoInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentedOnVideoInput>, Enumerable<CommentUncheckedCreateWithoutCommentedOnVideoInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentedOnVideoInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentedOnVideoInput>
    createMany?: CommentCreateManyCommentedOnVideoInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentedOnVideoInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentedOnVideoInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type VideoRatingUpdateManyWithoutVideoInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutVideoInput>, Enumerable<VideoRatingUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<VideoRatingUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: VideoRatingCreateManyVideoInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
    set?: Enumerable<VideoRatingWhereUniqueInput>
    disconnect?: Enumerable<VideoRatingWhereUniqueInput>
    delete?: Enumerable<VideoRatingWhereUniqueInput>
    update?: Enumerable<VideoRatingUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<VideoRatingUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<VideoRatingScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutCommentedOnVideoInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentedOnVideoInput>, Enumerable<CommentUncheckedCreateWithoutCommentedOnVideoInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentedOnVideoInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentedOnVideoInput>
    createMany?: CommentCreateManyCommentedOnVideoInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentedOnVideoInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentedOnVideoInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type VideoRatingUncheckedUpdateManyWithoutVideoInput = {
    create?: XOR<Enumerable<VideoRatingCreateWithoutVideoInput>, Enumerable<VideoRatingUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<VideoRatingCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<VideoRatingUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: VideoRatingCreateManyVideoInputEnvelope
    connect?: Enumerable<VideoRatingWhereUniqueInput>
    set?: Enumerable<VideoRatingWhereUniqueInput>
    disconnect?: Enumerable<VideoRatingWhereUniqueInput>
    delete?: Enumerable<VideoRatingWhereUniqueInput>
    update?: Enumerable<VideoRatingUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<VideoRatingUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<VideoRatingScalarWhereInput>
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutBaseCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutBaseCommentInput>, Enumerable<CommentUncheckedCreateWithoutBaseCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutBaseCommentInput>
    createMany?: CommentCreateManyBaseCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentCreateNestedOneWithoutDirectRepliesInput = {
    create?: XOR<CommentCreateWithoutDirectRepliesInput, CommentUncheckedCreateWithoutDirectRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDirectRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutReplyToCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutReplyToCommentInput>, Enumerable<CommentUncheckedCreateWithoutReplyToCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutReplyToCommentInput>
    createMany?: CommentCreateManyReplyToCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    connect?: VideoWhereUniqueInput
  }

  export type CommentRatingCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutCommentInput>, Enumerable<CommentRatingUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutCommentInput>
    createMany?: CommentRatingCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutBaseCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutBaseCommentInput>, Enumerable<CommentUncheckedCreateWithoutBaseCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutBaseCommentInput>
    createMany?: CommentCreateManyBaseCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutReplyToCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutReplyToCommentInput>, Enumerable<CommentUncheckedCreateWithoutReplyToCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutReplyToCommentInput>
    createMany?: CommentCreateManyReplyToCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentRatingUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutCommentInput>, Enumerable<CommentRatingUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutCommentInput>
    createMany?: CommentRatingCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
  }

  export type CommentUpdateOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutBaseCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutBaseCommentInput>, Enumerable<CommentUncheckedCreateWithoutBaseCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutBaseCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutBaseCommentInput>
    createMany?: CommentCreateManyBaseCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutBaseCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutBaseCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentUpdateOneWithoutDirectRepliesInput = {
    create?: XOR<CommentCreateWithoutDirectRepliesInput, CommentUncheckedCreateWithoutDirectRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDirectRepliesInput
    upsert?: CommentUpsertWithoutDirectRepliesInput
    connect?: CommentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CommentUpdateWithoutDirectRepliesInput, CommentUncheckedUpdateWithoutDirectRepliesInput>
  }

  export type CommentUpdateManyWithoutReplyToCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutReplyToCommentInput>, Enumerable<CommentUncheckedCreateWithoutReplyToCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutReplyToCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutReplyToCommentInput>
    createMany?: CommentCreateManyReplyToCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutReplyToCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutReplyToCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoUpdateOneRequiredWithoutCommentsInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    upsert?: VideoUpsertWithoutCommentsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentRatingUpdateManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutCommentInput>, Enumerable<CommentRatingUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentRatingUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentRatingCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
    set?: Enumerable<CommentRatingWhereUniqueInput>
    disconnect?: Enumerable<CommentRatingWhereUniqueInput>
    delete?: Enumerable<CommentRatingWhereUniqueInput>
    update?: Enumerable<CommentRatingUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentRatingUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentRatingScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutBaseCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutBaseCommentInput>, Enumerable<CommentUncheckedCreateWithoutBaseCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutBaseCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutBaseCommentInput>
    createMany?: CommentCreateManyBaseCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutBaseCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutBaseCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutReplyToCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutReplyToCommentInput>, Enumerable<CommentUncheckedCreateWithoutReplyToCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutReplyToCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutReplyToCommentInput>
    createMany?: CommentCreateManyReplyToCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutReplyToCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutReplyToCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentRatingUncheckedUpdateManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentRatingCreateWithoutCommentInput>, Enumerable<CommentRatingUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentRatingCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentRatingUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentRatingCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentRatingWhereUniqueInput>
    set?: Enumerable<CommentRatingWhereUniqueInput>
    disconnect?: Enumerable<CommentRatingWhereUniqueInput>
    delete?: Enumerable<CommentRatingWhereUniqueInput>
    update?: Enumerable<CommentRatingUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentRatingUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentRatingScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutVideoRatingsInput = {
    create?: XOR<UserCreateWithoutVideoRatingsInput, UserUncheckedCreateWithoutVideoRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutRatingsInput = {
    create?: XOR<VideoCreateWithoutRatingsInput, VideoUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutRatingsInput
    connect?: VideoWhereUniqueInput
  }

  export type EnumRatingStatusFieldUpdateOperationsInput = {
    set?: RatingStatus
  }

  export type UserUpdateOneRequiredWithoutVideoRatingsInput = {
    create?: XOR<UserCreateWithoutVideoRatingsInput, UserUncheckedCreateWithoutVideoRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoRatingsInput
    upsert?: UserUpsertWithoutVideoRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutVideoRatingsInput, UserUncheckedUpdateWithoutVideoRatingsInput>
  }

  export type VideoUpdateOneWithoutRatingsInput = {
    create?: XOR<VideoCreateWithoutRatingsInput, VideoUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutRatingsInput
    upsert?: VideoUpsertWithoutRatingsInput
    connect?: VideoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<VideoUpdateWithoutRatingsInput, VideoUncheckedUpdateWithoutRatingsInput>
  }

  export type UserCreateNestedOneWithoutCommentRatingsInput = {
    create?: XOR<UserCreateWithoutCommentRatingsInput, UserUncheckedCreateWithoutCommentRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRatingInput = {
    create?: XOR<CommentCreateWithoutRatingInput, CommentUncheckedCreateWithoutRatingInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRatingInput
    connect?: CommentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentRatingsInput = {
    create?: XOR<UserCreateWithoutCommentRatingsInput, UserUncheckedCreateWithoutCommentRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentRatingsInput
    upsert?: UserUpsertWithoutCommentRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentRatingsInput, UserUncheckedUpdateWithoutCommentRatingsInput>
  }

  export type CommentUpdateOneWithoutRatingInput = {
    create?: XOR<CommentCreateWithoutRatingInput, CommentUncheckedCreateWithoutRatingInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRatingInput
    upsert?: CommentUpsertWithoutRatingInput
    connect?: CommentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CommentUpdateWithoutRatingInput, CommentUncheckedUpdateWithoutRatingInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<UserCreateWithoutSubscribersInput, UserUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscribersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutSubscribersInput = {
    create?: XOR<UserCreateWithoutSubscribersInput, UserUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscribersInput
    upsert?: UserUpsertWithoutSubscribersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSubscribersInput, UserUncheckedUpdateWithoutSubscribersInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumProviderFilter = {
    equals?: Provider
    in?: Enumerable<Provider>
    notIn?: Enumerable<Provider>
    not?: NestedEnumProviderFilter | Provider
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumProviderWithAggregatesFilter = {
    equals?: Provider
    in?: Enumerable<Provider>
    notIn?: Enumerable<Provider>
    not?: NestedEnumProviderWithAggregatesFilter | Provider
    count?: NestedIntFilter
    min?: NestedEnumProviderFilter
    max?: NestedEnumProviderFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumRatingStatusFilter = {
    equals?: RatingStatus
    in?: Enumerable<RatingStatus>
    notIn?: Enumerable<RatingStatus>
    not?: NestedEnumRatingStatusFilter | RatingStatus
  }

  export type NestedEnumRatingStatusWithAggregatesFilter = {
    equals?: RatingStatus
    in?: Enumerable<RatingStatus>
    notIn?: Enumerable<RatingStatus>
    not?: NestedEnumRatingStatusWithAggregatesFilter | RatingStatus
    count?: NestedIntFilter
    min?: NestedEnumRatingStatusFilter
    max?: NestedEnumRatingStatusFilter
  }

  export type CommentCreateWithoutAuthorInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: Enumerable<CommentCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutChannelInput = {
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutChannelInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutChannelInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutChannelInput, VideoUncheckedCreateWithoutChannelInput>
  }

  export type VideoCreateManyChannelInputEnvelope = {
    data: Enumerable<VideoCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type CommentRatingCreateWithoutRatedByInput = {
    status: RatingStatus
    comment?: CommentCreateNestedOneWithoutRatingInput
  }

  export type CommentRatingUncheckedCreateWithoutRatedByInput = {
    id?: number
    status: RatingStatus
    commentId?: number | null
  }

  export type CommentRatingCreateOrConnectWithoutRatedByInput = {
    where: CommentRatingWhereUniqueInput
    create: XOR<CommentRatingCreateWithoutRatedByInput, CommentRatingUncheckedCreateWithoutRatedByInput>
  }

  export type CommentRatingCreateManyRatedByInputEnvelope = {
    data: Enumerable<CommentRatingCreateManyRatedByInput>
    skipDuplicates?: boolean
  }

  export type VideoRatingCreateWithoutRatedByInput = {
    status: RatingStatus
    video?: VideoCreateNestedOneWithoutRatingsInput
  }

  export type VideoRatingUncheckedCreateWithoutRatedByInput = {
    id?: number
    status: RatingStatus
    videoId?: number | null
  }

  export type VideoRatingCreateOrConnectWithoutRatedByInput = {
    where: VideoRatingWhereUniqueInput
    create: XOR<VideoRatingCreateWithoutRatedByInput, VideoRatingUncheckedCreateWithoutRatedByInput>
  }

  export type VideoRatingCreateManyRatedByInputEnvelope = {
    data: Enumerable<VideoRatingCreateManyRatedByInput>
    skipDuplicates?: boolean
  }

  export type SubscriberCreateWithoutUserInput = {
    channel: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriberUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
  }

  export type SubscriberCreateOrConnectWithoutUserInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutUserInput, SubscriberUncheckedCreateWithoutUserInput>
  }

  export type SubscriberCreateManyUserInputEnvelope = {
    data: Enumerable<SubscriberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SubscriberCreateWithoutChannelInput = {
    user: UserCreateNestedOneWithoutSubscribersInput
  }

  export type SubscriberUncheckedCreateWithoutChannelInput = {
    id?: number
    userId: number
  }

  export type SubscriberCreateOrConnectWithoutChannelInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutChannelInput, SubscriberUncheckedCreateWithoutChannelInput>
  }

  export type SubscriberCreateManyChannelInputEnvelope = {
    data: Enumerable<SubscriberCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    baseCommentId?: IntNullableFilter | number | null
    replyToCommentId?: IntNullableFilter | number | null
    userId?: IntFilter | number
    videoId?: IntFilter | number
    commentedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutChannelInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutChannelInput, VideoUncheckedUpdateWithoutChannelInput>
    create: XOR<VideoCreateWithoutChannelInput, VideoUncheckedCreateWithoutChannelInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutChannelInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutChannelInput, VideoUncheckedUpdateWithoutChannelInput>
  }

  export type VideoUpdateManyWithWhereWithoutChannelInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutVideosInput>
  }

  export type VideoScalarWhereInput = {
    AND?: Enumerable<VideoScalarWhereInput>
    OR?: Enumerable<VideoScalarWhereInput>
    NOT?: Enumerable<VideoScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    src?: StringFilter | string
    thumbnail?: StringFilter | string
    duration?: IntFilter | number
    userId?: IntFilter | number
    views?: IntNullableFilter | number | null
    uploadedAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentRatingUpsertWithWhereUniqueWithoutRatedByInput = {
    where: CommentRatingWhereUniqueInput
    update: XOR<CommentRatingUpdateWithoutRatedByInput, CommentRatingUncheckedUpdateWithoutRatedByInput>
    create: XOR<CommentRatingCreateWithoutRatedByInput, CommentRatingUncheckedCreateWithoutRatedByInput>
  }

  export type CommentRatingUpdateWithWhereUniqueWithoutRatedByInput = {
    where: CommentRatingWhereUniqueInput
    data: XOR<CommentRatingUpdateWithoutRatedByInput, CommentRatingUncheckedUpdateWithoutRatedByInput>
  }

  export type CommentRatingUpdateManyWithWhereWithoutRatedByInput = {
    where: CommentRatingScalarWhereInput
    data: XOR<CommentRatingUpdateManyMutationInput, CommentRatingUncheckedUpdateManyWithoutCommentRatingsInput>
  }

  export type CommentRatingScalarWhereInput = {
    AND?: Enumerable<CommentRatingScalarWhereInput>
    OR?: Enumerable<CommentRatingScalarWhereInput>
    NOT?: Enumerable<CommentRatingScalarWhereInput>
    id?: IntFilter | number
    status?: EnumRatingStatusFilter | RatingStatus
    userId?: IntFilter | number
    commentId?: IntNullableFilter | number | null
  }

  export type VideoRatingUpsertWithWhereUniqueWithoutRatedByInput = {
    where: VideoRatingWhereUniqueInput
    update: XOR<VideoRatingUpdateWithoutRatedByInput, VideoRatingUncheckedUpdateWithoutRatedByInput>
    create: XOR<VideoRatingCreateWithoutRatedByInput, VideoRatingUncheckedCreateWithoutRatedByInput>
  }

  export type VideoRatingUpdateWithWhereUniqueWithoutRatedByInput = {
    where: VideoRatingWhereUniqueInput
    data: XOR<VideoRatingUpdateWithoutRatedByInput, VideoRatingUncheckedUpdateWithoutRatedByInput>
  }

  export type VideoRatingUpdateManyWithWhereWithoutRatedByInput = {
    where: VideoRatingScalarWhereInput
    data: XOR<VideoRatingUpdateManyMutationInput, VideoRatingUncheckedUpdateManyWithoutVideoRatingsInput>
  }

  export type VideoRatingScalarWhereInput = {
    AND?: Enumerable<VideoRatingScalarWhereInput>
    OR?: Enumerable<VideoRatingScalarWhereInput>
    NOT?: Enumerable<VideoRatingScalarWhereInput>
    id?: IntFilter | number
    status?: EnumRatingStatusFilter | RatingStatus
    userId?: IntFilter | number
    videoId?: IntNullableFilter | number | null
  }

  export type SubscriberUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriberWhereUniqueInput
    update: XOR<SubscriberUpdateWithoutUserInput, SubscriberUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriberCreateWithoutUserInput, SubscriberUncheckedCreateWithoutUserInput>
  }

  export type SubscriberUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriberWhereUniqueInput
    data: XOR<SubscriberUpdateWithoutUserInput, SubscriberUncheckedUpdateWithoutUserInput>
  }

  export type SubscriberUpdateManyWithWhereWithoutUserInput = {
    where: SubscriberScalarWhereInput
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyWithoutSubscribersInput>
  }

  export type SubscriberScalarWhereInput = {
    AND?: Enumerable<SubscriberScalarWhereInput>
    OR?: Enumerable<SubscriberScalarWhereInput>
    NOT?: Enumerable<SubscriberScalarWhereInput>
    id?: IntFilter | number
    channelId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type SubscriberUpsertWithWhereUniqueWithoutChannelInput = {
    where: SubscriberWhereUniqueInput
    update: XOR<SubscriberUpdateWithoutChannelInput, SubscriberUncheckedUpdateWithoutChannelInput>
    create: XOR<SubscriberCreateWithoutChannelInput, SubscriberUncheckedCreateWithoutChannelInput>
  }

  export type SubscriberUpdateWithWhereUniqueWithoutChannelInput = {
    where: SubscriberWhereUniqueInput
    data: XOR<SubscriberUpdateWithoutChannelInput, SubscriberUncheckedUpdateWithoutChannelInput>
  }

  export type SubscriberUpdateManyWithWhereWithoutChannelInput = {
    where: SubscriberScalarWhereInput
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type UserCreateWithoutVideosInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateWithoutVideosInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserCreateOrConnectWithoutVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
  }

  export type CommentCreateWithoutCommentedOnVideoInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutCommentedOnVideoInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCommentedOnVideoInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentedOnVideoInput, CommentUncheckedCreateWithoutCommentedOnVideoInput>
  }

  export type CommentCreateManyCommentedOnVideoInputEnvelope = {
    data: Enumerable<CommentCreateManyCommentedOnVideoInput>
    skipDuplicates?: boolean
  }

  export type VideoRatingCreateWithoutVideoInput = {
    status: RatingStatus
    ratedBy: UserCreateNestedOneWithoutVideoRatingsInput
  }

  export type VideoRatingUncheckedCreateWithoutVideoInput = {
    id?: number
    status: RatingStatus
    userId: number
  }

  export type VideoRatingCreateOrConnectWithoutVideoInput = {
    where: VideoRatingWhereUniqueInput
    create: XOR<VideoRatingCreateWithoutVideoInput, VideoRatingUncheckedCreateWithoutVideoInput>
  }

  export type VideoRatingCreateManyVideoInputEnvelope = {
    data: Enumerable<VideoRatingCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVideosInput = {
    update: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
  }

  export type UserUpdateWithoutVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type CommentUpsertWithWhereUniqueWithoutCommentedOnVideoInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCommentedOnVideoInput, CommentUncheckedUpdateWithoutCommentedOnVideoInput>
    create: XOR<CommentCreateWithoutCommentedOnVideoInput, CommentUncheckedCreateWithoutCommentedOnVideoInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCommentedOnVideoInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCommentedOnVideoInput, CommentUncheckedUpdateWithoutCommentedOnVideoInput>
  }

  export type CommentUpdateManyWithWhereWithoutCommentedOnVideoInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type VideoRatingUpsertWithWhereUniqueWithoutVideoInput = {
    where: VideoRatingWhereUniqueInput
    update: XOR<VideoRatingUpdateWithoutVideoInput, VideoRatingUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoRatingCreateWithoutVideoInput, VideoRatingUncheckedCreateWithoutVideoInput>
  }

  export type VideoRatingUpdateWithWhereUniqueWithoutVideoInput = {
    where: VideoRatingWhereUniqueInput
    data: XOR<VideoRatingUpdateWithoutVideoInput, VideoRatingUncheckedUpdateWithoutVideoInput>
  }

  export type VideoRatingUpdateManyWithWhereWithoutVideoInput = {
    where: VideoRatingScalarWhereInput
    data: XOR<VideoRatingUpdateManyMutationInput, VideoRatingUncheckedUpdateManyWithoutRatingsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutBaseCommentInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutBaseCommentInput = {
    id?: number
    text: string
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutBaseCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutBaseCommentInput, CommentUncheckedCreateWithoutBaseCommentInput>
  }

  export type CommentCreateManyBaseCommentInputEnvelope = {
    data: Enumerable<CommentCreateManyBaseCommentInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutDirectRepliesInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutDirectRepliesInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutDirectRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutDirectRepliesInput, CommentUncheckedCreateWithoutDirectRepliesInput>
  }

  export type CommentCreateWithoutReplyToCommentInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
    Rating?: CommentRatingCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutReplyToCommentInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutReplyToCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReplyToCommentInput, CommentUncheckedCreateWithoutReplyToCommentInput>
  }

  export type CommentCreateManyReplyToCommentInputEnvelope = {
    data: Enumerable<CommentCreateManyReplyToCommentInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCommentsInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    videos?: VideoCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type VideoCreateWithoutCommentsInput = {
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    channel?: UserCreateNestedOneWithoutVideosInput
    ratings?: VideoRatingCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    userId: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    ratings?: VideoRatingUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutCommentsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
  }

  export type CommentRatingCreateWithoutCommentInput = {
    status: RatingStatus
    ratedBy: UserCreateNestedOneWithoutCommentRatingsInput
  }

  export type CommentRatingUncheckedCreateWithoutCommentInput = {
    id?: number
    status: RatingStatus
    userId: number
  }

  export type CommentRatingCreateOrConnectWithoutCommentInput = {
    where: CommentRatingWhereUniqueInput
    create: XOR<CommentRatingCreateWithoutCommentInput, CommentRatingUncheckedCreateWithoutCommentInput>
  }

  export type CommentRatingCreateManyCommentInputEnvelope = {
    data: Enumerable<CommentRatingCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentUpsertWithWhereUniqueWithoutBaseCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutBaseCommentInput, CommentUncheckedUpdateWithoutBaseCommentInput>
    create: XOR<CommentCreateWithoutBaseCommentInput, CommentUncheckedCreateWithoutBaseCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutBaseCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutBaseCommentInput, CommentUncheckedUpdateWithoutBaseCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutBaseCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutRepliesInput>
  }

  export type CommentUpsertWithoutDirectRepliesInput = {
    update: XOR<CommentUpdateWithoutDirectRepliesInput, CommentUncheckedUpdateWithoutDirectRepliesInput>
    create: XOR<CommentCreateWithoutDirectRepliesInput, CommentUncheckedCreateWithoutDirectRepliesInput>
  }

  export type CommentUpdateWithoutDirectRepliesInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutDirectRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentUpsertWithWhereUniqueWithoutReplyToCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutReplyToCommentInput, CommentUncheckedUpdateWithoutReplyToCommentInput>
    create: XOR<CommentCreateWithoutReplyToCommentInput, CommentUncheckedCreateWithoutReplyToCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutReplyToCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutReplyToCommentInput, CommentUncheckedUpdateWithoutReplyToCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutReplyToCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutDirectRepliesInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: VideoUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type VideoUpsertWithoutCommentsInput = {
    update: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
  }

  export type VideoUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: UserUpdateOneWithoutVideosInput
    ratings?: VideoRatingUpdateManyWithoutVideoInput
  }

  export type VideoUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: VideoRatingUncheckedUpdateManyWithoutVideoInput
  }

  export type CommentRatingUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentRatingWhereUniqueInput
    update: XOR<CommentRatingUpdateWithoutCommentInput, CommentRatingUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentRatingCreateWithoutCommentInput, CommentRatingUncheckedCreateWithoutCommentInput>
  }

  export type CommentRatingUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentRatingWhereUniqueInput
    data: XOR<CommentRatingUpdateWithoutCommentInput, CommentRatingUncheckedUpdateWithoutCommentInput>
  }

  export type CommentRatingUpdateManyWithWhereWithoutCommentInput = {
    where: CommentRatingScalarWhereInput
    data: XOR<CommentRatingUpdateManyMutationInput, CommentRatingUncheckedUpdateManyWithoutRatingInput>
  }

  export type UserCreateWithoutVideoRatingsInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    videos?: VideoCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateWithoutVideoRatingsInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserCreateOrConnectWithoutVideoRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoRatingsInput, UserUncheckedCreateWithoutVideoRatingsInput>
  }

  export type VideoCreateWithoutRatingsInput = {
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    channel?: UserCreateNestedOneWithoutVideosInput
    comments?: CommentCreateNestedManyWithoutCommentedOnVideoInput
  }

  export type VideoUncheckedCreateWithoutRatingsInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    userId: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutCommentedOnVideoInput
  }

  export type VideoCreateOrConnectWithoutRatingsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutRatingsInput, VideoUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutVideoRatingsInput = {
    update: XOR<UserUpdateWithoutVideoRatingsInput, UserUncheckedUpdateWithoutVideoRatingsInput>
    create: XOR<UserCreateWithoutVideoRatingsInput, UserUncheckedCreateWithoutVideoRatingsInput>
  }

  export type UserUpdateWithoutVideoRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    videos?: VideoUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateWithoutVideoRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type VideoUpsertWithoutRatingsInput = {
    update: XOR<VideoUpdateWithoutRatingsInput, VideoUncheckedUpdateWithoutRatingsInput>
    create: XOR<VideoCreateWithoutRatingsInput, VideoUncheckedCreateWithoutRatingsInput>
  }

  export type VideoUpdateWithoutRatingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: UserUpdateOneWithoutVideosInput
    comments?: CommentUpdateManyWithoutCommentedOnVideoInput
  }

  export type VideoUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutCommentedOnVideoInput
  }

  export type UserCreateWithoutCommentRatingsInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    videos?: VideoCreateNestedManyWithoutChannelInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateWithoutCommentRatingsInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserCreateOrConnectWithoutCommentRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentRatingsInput, UserUncheckedCreateWithoutCommentRatingsInput>
  }

  export type CommentCreateWithoutRatingInput = {
    text: string
    commentedAt?: Date | string
    editedAt?: Date | string
    baseComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutBaseCommentInput
    replyToComment?: CommentCreateNestedOneWithoutDirectRepliesInput
    directReplies?: CommentCreateNestedManyWithoutReplyToCommentInput
    author: UserCreateNestedOneWithoutCommentsInput
    commentedOnVideo: VideoCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRatingInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedCreateNestedManyWithoutReplyToCommentInput
  }

  export type CommentCreateOrConnectWithoutRatingInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRatingInput, CommentUncheckedCreateWithoutRatingInput>
  }

  export type UserUpsertWithoutCommentRatingsInput = {
    update: XOR<UserUpdateWithoutCommentRatingsInput, UserUncheckedUpdateWithoutCommentRatingsInput>
    create: XOR<UserCreateWithoutCommentRatingsInput, UserUncheckedCreateWithoutCommentRatingsInput>
  }

  export type UserUpdateWithoutCommentRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    videos?: VideoUpdateManyWithoutChannelInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateWithoutCommentRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type CommentUpsertWithoutRatingInput = {
    update: XOR<CommentUpdateWithoutRatingInput, CommentUncheckedUpdateWithoutRatingInput>
    create: XOR<CommentCreateWithoutRatingInput, CommentUncheckedCreateWithoutRatingInput>
  }

  export type CommentUpdateWithoutRatingInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
  }

  export type CommentUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    videos?: VideoCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserCreateWithoutSubscribersInput = {
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    videos?: VideoCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingCreateNestedManyWithoutRatedByInput
    subscriptions?: SubscriberCreateNestedManyWithoutChannelInput
  }

  export type UserUncheckedCreateWithoutSubscribersInput = {
    id?: number
    name: string
    email: string
    picture?: string | null
    provider: Provider
    providerAccountId: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    videos?: VideoUncheckedCreateNestedManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedCreateNestedManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedCreateNestedManyWithoutRatedByInput
    subscriptions?: SubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type UserCreateOrConnectWithoutSubscribersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscribersInput, UserUncheckedCreateWithoutSubscribersInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    videos?: VideoUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutSubscribersInput = {
    update: XOR<UserUpdateWithoutSubscribersInput, UserUncheckedUpdateWithoutSubscribersInput>
    create: XOR<UserCreateWithoutSubscribersInput, UserUncheckedCreateWithoutSubscribersInput>
  }

  export type UserUpdateWithoutSubscribersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorInput
    videos?: VideoUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUpdateManyWithoutRatedByInput
    subscriptions?: SubscriberUpdateManyWithoutChannelInput
  }

  export type UserUncheckedUpdateWithoutSubscribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | Provider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorInput
    videos?: VideoUncheckedUpdateManyWithoutChannelInput
    commentRatings?: CommentRatingUncheckedUpdateManyWithoutRatedByInput
    videoRatings?: VideoRatingUncheckedUpdateManyWithoutRatedByInput
    subscriptions?: SubscriberUncheckedUpdateManyWithoutChannelInput
  }

  export type CommentCreateManyAuthorInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
  }

  export type VideoCreateManyChannelInput = {
    id?: number
    title: string
    description: string
    src: string
    thumbnail: string
    duration: number
    views?: number | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentRatingCreateManyRatedByInput = {
    id?: number
    status: RatingStatus
    commentId?: number | null
  }

  export type VideoRatingCreateManyRatedByInput = {
    id?: number
    status: RatingStatus
    videoId?: number | null
  }

  export type SubscriberCreateManyUserInput = {
    id?: number
    channelId: number
  }

  export type SubscriberCreateManyChannelInput = {
    id?: number
    userId: number
  }

  export type CommentUpdateWithoutAuthorInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutChannelInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUpdateManyWithoutVideoInput
  }

  export type VideoUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutCommentedOnVideoInput
    ratings?: VideoRatingUncheckedUpdateManyWithoutVideoInput
  }

  export type VideoUncheckedUpdateManyWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentRatingUpdateWithoutRatedByInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    comment?: CommentUpdateOneWithoutRatingInput
  }

  export type CommentRatingUncheckedUpdateWithoutRatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentRatingUncheckedUpdateManyWithoutCommentRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoRatingUpdateWithoutRatedByInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    video?: VideoUpdateOneWithoutRatingsInput
  }

  export type VideoRatingUncheckedUpdateWithoutRatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    videoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoRatingUncheckedUpdateManyWithoutVideoRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    videoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubscriberUpdateWithoutUserInput = {
    channel?: UserUpdateOneRequiredWithoutSubscriptionsInput
  }

  export type SubscriberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriberUncheckedUpdateManyWithoutSubscribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriberUpdateWithoutChannelInput = {
    user?: UserUpdateOneRequiredWithoutSubscribersInput
  }

  export type SubscriberUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriberUncheckedUpdateManyWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyCommentedOnVideoInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    replyToCommentId?: number | null
    userId: number
    commentedAt?: Date | string
    editedAt?: Date | string
  }

  export type VideoRatingCreateManyVideoInput = {
    id?: number
    status: RatingStatus
    userId: number
  }

  export type CommentUpdateWithoutCommentedOnVideoInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutCommentedOnVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type VideoRatingUpdateWithoutVideoInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    ratedBy?: UserUpdateOneRequiredWithoutVideoRatingsInput
  }

  export type VideoRatingUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type VideoRatingUncheckedUpdateManyWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyBaseCommentInput = {
    id?: number
    text: string
    replyToCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
  }

  export type CommentCreateManyReplyToCommentInput = {
    id?: number
    text: string
    baseCommentId?: number | null
    userId: number
    videoId: number
    commentedAt?: Date | string
    editedAt?: Date | string
  }

  export type CommentRatingCreateManyCommentInput = {
    id?: number
    status: RatingStatus
    userId: number
  }

  export type CommentUpdateWithoutBaseCommentInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUpdateManyWithoutBaseCommentInput
    replyToComment?: CommentUpdateOneWithoutDirectRepliesInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutBaseCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    replyToCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutReplyToCommentInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseComment?: CommentUpdateOneWithoutRepliesInput
    replies?: CommentUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUpdateManyWithoutReplyToCommentInput
    author?: UserUpdateOneRequiredWithoutCommentsInput
    commentedOnVideo?: VideoUpdateOneRequiredWithoutCommentsInput
    Rating?: CommentRatingUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateWithoutReplyToCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutBaseCommentInput
    directReplies?: CommentUncheckedUpdateManyWithoutReplyToCommentInput
    Rating?: CommentRatingUncheckedUpdateManyWithoutCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutDirectRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    baseCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentRatingUpdateWithoutCommentInput = {
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    ratedBy?: UserUpdateOneRequiredWithoutCommentRatingsInput
  }

  export type CommentRatingUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentRatingUncheckedUpdateManyWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRatingStatusFieldUpdateOperationsInput | RatingStatus
    userId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}